


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 5:32:16
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 
// 2. 
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;


int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	//std::sort 정렬
	for (int num : a)
		print("{:8}", num);


	save("STL.cpp");
}

int 정렬기준(const void*, const void*) {
	return 12345;
}


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 5:34:27
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 
// 2. 
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
#include <algorithm>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;


int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	//std::sort 정렬 - default 오름차순(ascending order)
	std::sort(a.begin(), a.end());

	for (int num : a)
		print("{:8}", num);


	save("STL.cpp");
}

int 정렬기준(const void*, const void*) {
	return 12345;
}


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 5:37:37
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
#include <algorithm>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;


int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	//std::sort 정렬 - default 오름차순(ascending order)
	bool f(int, int);
	std::sort(a.begin(), a.end(), f);

	for (int num : a)
		print("{:8}", num);


	save("STL.cpp");
}

int 정렬기준(const void*, const void*) {
	return 12345;
}

bool f(int a, int b) {
	return a > b;
}


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 5:51:25
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
#include <algorithm>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;


int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	//std::sort 정렬 - default 오름차순(ascending order)
	bool f(int, int);
	std::sort(a.begin(), a.end(), f);

	for (int num : a)
		print("{:8}", num);


	save("STL.cpp");
}

int 정렬기준(const void*, const void*) {
	return 12345;
}

bool f(int a, int b) {
	cout << a << " <-> " << b << endl;
	return a > b;
}


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 5:52:34
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
#include <algorithm>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;
int fcnt = 0;

int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	//std::sort 정렬 - default 오름차순(ascending order)
	bool f(int, int);
	std::sort(a.begin(), a.end(), f);

	for (int num : a)
		print("{:8}", num);

	cout << "sotrt의 비교 함수 호출 - " << fcnt << endl;

	save("STL.cpp");
}

int 정렬기준(const void*, const void*) {
	return 12345;
}

bool f(int a, int b) {
	cout << a << " <-> " << b << endl;
	++fcnt;
	return a > b;
}


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 5:58:10
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
#include <algorithm>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;
int fcnt = 0;
bool f(int, int);

int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	std::sort(a.begin(), a.end(), [](int a, int b) {
		return a > b;
		});// 가독성 훌륭한 코드 내림차순 

	for (int num : a)
		print("{:8}", num);

	save("STL.cpp");
}


bool f(int a, int b) {
	return a > b;
}


================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:15:43
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <print>
#include <algorithm>
using namespace std;

//[문제] : [10'000, 99'999] 범위의 값을 갖는 int 100개를 만들어 주세요
// std::sort를 사용하여 오름차순을 정렬하ㅔ요	
// 정렬한 결과를 화면에 보여주세요

uniform_int_distribution uid{ 1, 1'000 };
default_random_engine dre;

array<int, 100> a;
//
//class Dog {
//public:
//	int operator+(const Dog& rhs) {
//
//	}
//};

class Dog {
public:
	bool operator()(int a, int b) {
		return a > b;
	}
};

int main()
{
	for (int& num : a) {
		num = uid(dre);
	}

	std::sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		print("{:8}", num);

	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:22:09
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;



int main()
{
	//람다
	[]() {
		cout << "HELLO LAMBDA" << endl;
		}; 


	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:23:13
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;



int main()
{
	//람다
	[]() {
		cout << "HELLO LAMBDA" << endl;
		}(); 


	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:26:18
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;



int main()
{
	//람다
	auto 람다 = []() {
		cout << "HELLO LAMBDA" << endl;
		}; 

	cout << typeid(람다).name() << endl;


	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:31:05
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f() {
	auto 람다 = []() {
		cout << "HELLO LAMBDA" << endl;
		};

	cout << typeid(람다).name() << endl;
}

int main()
{
	f();
	f();



	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:44:25
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// 호출 가능한 타입을 대표하는 타입을 만들었따 - function
// 
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다 -> visual studio에서는 함수 객체 라고 단언 가능
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체 -> 함수 객체
// 
// ----------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"
using namespace std;

void f(bool (*x)(int a, int b)) {
	x(3, 5);
}


int main()
{
	f([](int a, int b)->bool {
		return true;
		});
	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 6:45:31
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// 호출 가능한 타입을 대표하는 타입을 만들었따 - function
// 
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다 -> visual studio에서는 함수 객체 라고 단언 가능
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체 -> 함수 객체
// 
// ----------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"
using namespace std;

void f(function<bool(int,int)> x) {
	x(3, 5);
}


int main()
{
	f([](int a, int b)->bool {
		return true;
		});
	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 7:04:56
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// 호출 가능한 타입을 대표하는 타입을 만들었따 - function
// 
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다 -> visual studio에서는 함수 객체 라고 단언 가능
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체 -> 함수 객체
// 
// ----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

class String {
	size_t len{};
	unique_ptr<char[]> p;

public:
	String(const char* s) : len(strlen(s)) {
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}
	friend ostream& operator<<(ostream& os, const String& s) {
		for (size_t i = 0; i < s.len; ++i)
			os << s.p.get()[i];
		return os;
	}
};
int main()
{
	String s{ "STL을 관찰하기 위한 클래스입니다." };

	cout << s << endl;

	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-04-01 월요일 오후 7:05:36
================================================
//----------------------------------------------------------
// 2024 STL 4.1 화 (5-1주차)
//  
// callable type - 무한한 타입이 있다.
// 호출 가능한 타입을 대표하는 타입을 만들었따 - function
// 
// sort할 때 어떤 기준으로 정렬할지를 어떻게 sort 함수에게 알려주나?
// 1. 함수포인터를 전닳나다
// 2. 람다를 전달한다 -> visual studio에서는 함수 객체 라고 단언 가능
// 3. () 연산자(FUNCTION CALL)를 오버로딩한 클래스의 객체 -> 함수 객체
// 
// ----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

class String {
	size_t len{};
	unique_ptr<char[]> p;

public:
	String(const char* s) : len(strlen(s)) {
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}
	friend ostream& operator<<(ostream& os, const String& s) {
		for (size_t i = 0; i < s.len; ++i)
			os << s.p.get()[i];
		return os;
	}
};
int main()
{
	String s{ "STL을 관찰하기 위한 클래스입니다." };
	//String t = s; -> 돌아갈 수 있게 코딩

	cout << s << endl;
	//cout << t << endl;

	save("STL.cpp");
}
