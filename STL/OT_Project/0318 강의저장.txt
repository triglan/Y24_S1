


================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 5:36:58
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시		(1-1)
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <fstream>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a','z' };
uniform_int_distribution uidNum{ 1, 99999 };

class Dog {
	char c{ (char)uidChar(dre) };
	int num{ uidNum(dre) };

public:
	Dog() {
		cout << "디폴트 생성" << endl;
	}
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 : " << dog.c << ", 숫자 : " << dog.num;
	}
};

int main()
{
	array<Dog, 100> dogs{};
	//문제 : dogs를 binary mode/write로 파일에 기록해라.
	ofstream out{ "개들", ios::binary };
	out.write((char*)dogs.data(), sizeof(Dog) * 100);

	//기록된 파일을 읽어서 num값이 가장 큰 dog를 찾아 화면에 출력


	save("STL.cpp");
}

//내가 했던 것
//int main()
//{
//	array<Dog, 100> dogs{};
//	//문제 : dogs를 binary mode/write로 파일에 기록해라.
//	//기록된 파일을 읽어서 num값이 가장 큰 dog를 찾아 화면에 출력
//
//
//	ofstream out{ "dogsData.txt", ios::binary };
//	out.write((const char*)dogs.data(), dogs.size() * sizeof(int) * 2);
//
//	ifstream in("dogsData.txt", ios::binary);
//	if (not in)
//		exit(0);
//	
//	array<Dog, 100> indogs{};
//
//	in.read((char*)indogs.data(), dogs.size() * sizeof(int) * 2);
//
//	cout << "최대값 : " << * max_element(istream_iterator<int>{in}, {});// 최대값 출력중
//
//
//	save("STL.cpp");
//}


================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 5:45:22
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시		(1-1)
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라

class Dog {
	char c;
	int num;

public:
	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}
};

int main()
{
	ifstream in{ "개들" };
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}

	Dog dog;
	for (int i = 0; i < 100; ++i) {
		in.read((char*)&dog, sizeof(Dog));
		dog.show();
	}


	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 5:52:48
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시		(1-1)
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라

class Dog {
	char c;
	int num;

public:
	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}
};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}

	//100번 Dog정보 - char - i, num - 38857
	array<Dog, 100> dogs;
	in.read((char*)dogs.data(), sizeof(Dog) * 100);
	dogs[99].show();

	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:04:41
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시		(1-1)
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.

class Dog {
	char c;
	int num;

public:
	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		is.read((char*)&dog, sizeof(Dog));
		return is;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}

	Dog dog;
	int cnt{};

	while (in >> dog)
		++cnt;
	cout << "Dog 개수 - " << cnt << endl;
	cout << "100번째 Dog의 정보 - ";
	dog.show();

	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:12:33
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.
//[2] class Dog 객체 100개 기록되어 있다.

class Dog {
	char c;
	int num;

public:
	int getNum() const {
		return num;
	}

	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}
	array<Dog, 100> dogs;
	in.read((char*)dogs.data(), sizeof(Dog) * 100);
		
	Dog maxDog;
	int maxValue{ numeric_limits<int>::min() };

	for (const Dog& dog : dogs) {
		if (maxValue < dog.getNum()) {
			maxDog = dog;
			maxValue = dog.getNum();
		}
	}

	cout << "Num값이 가장 큰 dog" << endl;
	maxDog.show();

	save("STL.cpp");
}



================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:53:50
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <algorithm>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.
//[2] class Dog 객체 100개 기록되어 있다.
//[3] 1000미만인 Dog 객체의 수를 출력해라.

class Dog {
	char c;
	int num;

public:
	int getNum() const {
		return num;
	}

	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}
	array<Dog, 100> dogs;
	in.read((char*)&dogs, sizeof(Dog) * 100);
		
	//1000미만의 dog를 출력하기 위해 count 사용
	int cnt = count_if(dogs.begin(), dogs.end(), [](const Dog& dog) {
		return 1000 > dog.getNum();
		});
	cout << "값이 1000 미만인 Dog의 개수 - " << cnt << endl;
	save("STL.cpp");
}


================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:54:51
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <algorithm>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.
//[2] class Dog 객체 100개 기록되어 있다.
//[3] 1000미만인 Dog 객체의 수를 출력해라.

class Dog {
	char c;
	int num;

public:
	int getNum() const {
		return num;
	}

	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}
	array<Dog, 100> dogs;
	in.read((char*)&dogs, sizeof(Dog) * 100);
		
	//1000미만의 dog를 출력하기 위해 count 사용
	int cnt = count_if(dogs.begin(), dogs.end(), [](const Dog& dog) {
		return 10000 > dog.getNum();
		});
	cout << "값이 1000 미만인 Dog의 개수 - " << cnt << endl;
	save("STL.cpp");
}


================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:55:03
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <algorithm>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.
//[2] class Dog 객체 100개 기록되어 있다.
//[3] 1000미만인 Dog 객체의 수를 출력해라.

class Dog {
	char c;
	int num;

public:
	int getNum() const {
		return num;
	}

	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}
	array<Dog, 100> dogs;
	in.read((char*)&dogs, sizeof(Dog) * 100);
		
	//1000미만의 dog를 출력하기 위해 count 사용
	int cnt = count_if(dogs.begin(), dogs.end(), [](const Dog& dog) {
		return 50000 > dog.getNum();
		});
	cout << "값이 1000 미만인 Dog의 개수 - " << cnt << endl;
	save("STL.cpp");
}


================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:55:34
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시
// 24-03-18 
// 개들 생성
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <algorithm>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.
//[2] class Dog 객체 100개 기록되어 있다.
//[3] 1000미만인 Dog 객체의 수를 출력해라.

class Dog {
	char c;
	int num;

public:
	int getNum() const {
		return num;
	}

	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}
	array<Dog, 100> dogs;
	in.read((char*)&dogs, sizeof(Dog) * 100);
		
	//1000미만의 dog를 출력하기 위해 count 사용
	int cnt = count_if(dogs.begin(), dogs.end(), [](const Dog& dog) {
		return dog.getNum() % 2; // 홀수 일 때 참, 짝수 일 때 거짓
		});
	cout << "값이 1000 미만인 Dog의 개수 - " << cnt << endl;
	save("STL.cpp");
}


================================================
STL.cpp, 저장시간: 2024-03-18 월요일 오후 6:57:54
================================================
//----------------------------------------------------------
// 2024 STL 3.5 월 9-10시
// 24-03-18 
// 실행 파일의 메모리 영역 - STACK CODE DATA Free store(Heap)
// ----------------------------------------------------------

#include <iostream>
#include "save.h"
#include <fstream>
#include <algorithm>
#include <array>
using namespace std;

//[문제] eclass에 가면 개들 파일이 있다. 파일을 binary모드로 기록했다.
//여기에는 class Dog 객체 100개 가록되어 있다. write함수를 사용하여 기록하였다.
//class Dog의 멤버는 다음과 같다.
//파일을 읽어 num값이 가장 큰 dog객체를 화면에 출력하라
//[변형] -->	여기에는 몇 개 인지 모르는 class Dog 객체를 write했다.
//[2] class Dog 객체 100개 기록되어 있다.
//[3] 1000미만인 Dog 객체의 수를 출력해라.

class Dog {
	char c;
	int num;

public:
	int getNum() const {
		return num;
	}

	void show() const {
		cout << "char - " << c << ", num - " << num << endl;
	}

};

int main()
{
	//바이너리로 열지 않았는데도 정상적으로 종료되면서 정상적인 것처럼 보이기에 조심해야 된다
	//이 파일은 어떻게 기록되어 있는지 binary 기억해라.
	ifstream in{ "개들", ios::binary};
	if (not in) {
		cout << "파일을 열 수 없다" << endl;
		return 0;
	}
	array<Dog, 100> dogs;
	in.read((char*)&dogs, sizeof(Dog) * 100);
		
	//1000미만의 dog를 출력하기 위해 count 사용
	int cnt = count_if(dogs.begin(), dogs.end(), [](const Dog& dog) {
		return dog.getNum() % 2; // 홀수 일 때 참, 짝수 일 때 거짓
		});
	cout << "값이 1000 미만인 Dog의 개수 - " << cnt << endl;
	save("STL.cpp");
}