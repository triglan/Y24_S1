


================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 5:35:10
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// 
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
using namespace std;
extern bool 관찰;


int main()
{
	set<int> s{ 1, 3, 5, 7, 9 };//int를 담으면 안되겠지만.
	for (int num : s)
		cout << num << " ";
	cout << endl;

	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 5:35:33
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// 
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
using namespace std;
extern bool 관찰;


int main()
{
	set<int> s{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };//int를 담으면 안되겠지만.
	for (int num : s)
		cout << num << " ";
	cout << endl;

	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 5:36:07
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// 
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
using namespace std;
extern bool 관찰;


int main()
{
	//실행시켜보면 1 2 3 4 5 6 7 8 9 10으로 아농ㄴ다. 정렬한 상태로 key값을 contain하고 있네
	set<int> s{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };//int를 담으면 안되겠지만.

	for (int num : s)
		cout << num << " ";
	cout << endl;

	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 5:37:14
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// 
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
using namespace std;
extern bool 관찰;


int main()
{
	//실행시켜보면 1 2 3 4 5 6 7 8 9 10으로 아농ㄴ다. 정렬한 상태로 key값을 contain하고 있네
	//돌려보면 1이 중복으로 안나온다고
	set<int> s{ 1,1,1,1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };//int를 담으면 안되겠지만.

	for (int num : s)
		cout << num << " ";
	cout << endl;

	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 5:43:57
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
using namespace std;
extern bool 관찰;


int main()
{
	//실행시켜보면 1 2 3 4 5 6 7 8 9 10으로 아농ㄴ다. 정렬한 상태로 key값을 contain하고 있네
	//돌려보면 1이 중복으로 안나온다고
	//uniqueness의 판단이 1==1이여서 제외하는게 아니라.
	//a < b 이 연산자를 이용해 판단하기 때문이다.
	//!(1 < 1) && !(1 < 1) --> a<b, b<a 이걸 물어보고 있는 거임 
	// ==> equivalence(동등한 자격을 갖는) 관계라고 부른다
	set<int> s{ 1, 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };//int를 담으면 안되겠지만.

	for (int num : s)
		cout << num << " ";
	cout << endl;

	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:01:21
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	set<String> s;

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	s = {istream_iterator<String>{in}, {}};
	cout << "unique한 단어 - " << s.size() << endl;
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:02:46
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	set<String> s;

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:03:26
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	set<String> s;

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:03:40
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	set<String> s;

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:07:10
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	set<String, std::less<String>> s;
	//이게 디폴트 정렬기준 왜 영사전 단어 기준 정렬을 했냐의 답이다.


	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:11:30
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// set은 unique한 key값을 정렬 상태로 유지한다.
// unuiqueness는 equivalance 관계를 이용하여 결정한다
// !(1 < 1) && !(1 < 1) => equivalence(동등한) 관계
// 
// 반대되는, 비교해서 공부해 둘 내용
// a == b => equality(상등) 관계
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	set<String, std::less<String>> s;
	//이게 디폴트 정렬기준 왜 영사전 단어 기준 정렬을 했냐의 답이다.


	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:12:51
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


int main()
{
	less a;
	cout << a(3, 4);

	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:25:51
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;



bool 길이(const String& a, const String& b) {//predicate
	return a.getLen() < b.getLen();
}

int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	//set은 단어길이기준 오름차순으로 정렬해야 한다.

	set<String, bool(*)(const String&, const String&)> s{ 길이 };
	//+ 이런 타입이고, 실제 함수는 저거야s{길이}

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:31:24
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


struct 람다 {
	bool operator()(const String& a, const String& b) const {//predicate
		return a.getLen() < b.getLen();
	}
};


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	//set은 단어길이기준 오름차순으로 정렬해야 한다.

	//+ 이런 타입이고, 실제 함수는 저거야s{길이}
	//set<String, bool(*)(const String&, const String&)> s{ 길이 };

	//+ 람다로 바꿔볼께
	set<String, 람다> s;

	//+민수 람다
	//set <String, bool(*)(const String& l, const String& r)> s{ [](const String& l, const String& r) {
	//return l.getLen() < r.getLen();
	//} };
	

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:32:18
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


struct 람다 {
	bool operator()(const String& a, const String& b) const {//predicate
		return a.getLen() < b.getLen();
	}
};


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	//set은 단어길이기준 오름차순으로 정렬해야 한다.

	//+ 이런 타입이고, 실제 함수는 저거야s{길이}
	//set<String, bool(*)(const String&, const String&)> s{ 길이 };

	//+ 람다로 바꿔볼께
	multiset<String, 람다> s;

	//+민수 람다
	//set <String, bool(*)(const String& l, const String& r)> s{ [](const String& l, const String& r) {
	//return l.getLen() < r.getLen();
	//} };
	

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << "unique한 단어 - " << s.size() << endl;//2948개 단어
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:33:04
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
using namespace std;
extern bool 관찰;


struct 람다 {
	bool operator()(const String& a, const String& b) const {//predicate
		return a.getLen() < b.getLen();
	}
};


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	//set은 단어길이기준 오름차순으로 정렬해야 한다.

	//+ 이런 타입이고, 실제 함수는 저거야s{길이}
	//set<String, bool(*)(const String&, const String&)> s{ 길이 };

	//+ 람다로 바꿔볼께
	multiset<String, 람다> s;

	//+민수 람다
	//set <String, bool(*)(const String& l, const String& r)> s{ [](const String& l, const String& r) {
	//return l.getLen() < r.getLen();
	//} };
	

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	//+바뀜 읽은 단어 수
	cout << "읽은 multiset의 단어 - " << s.size() << endl;
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:43:33
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
#include <cctype>
using namespace std;
extern bool 관찰;


struct 람다 {
	bool operator()(const String& a, const String& b) const {//predicate
		//대문자 먼저
		if (islower(*a.begin()) && isupper(*b.begin()))
			return false;
		return true;
	}
};


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 set에 읽어 와라.
	//set은 대문자로 시작하는 단어가 먼저 나와야 한다. //+

	// 이런 타입이고, 실제 함수는 저거야s{길이}
	//set<String, bool(*)(const String&, const String&)> s{ 길이 };

	// 람다로 바꿔볼께
	multiset<String, 람다> s;

	//민수 람다
	//set <String, bool(*)(const String& l, const String& r)> s{ [](const String& l, const String& r) {
	//return l.getLen() < r.getLen();
	//} };
	

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	//1번쨰 방법
	String str;
	while (in >> str)
		s.insert(str);

	//2번째 방법
	//s = {istream_iterator<String>{in}, {}};
	
	for (const String& str : s)
		cout << str<< endl;
	
	//바뀜 읽은 단어 수
	cout << "읽은 multiset의 단어 - " << s.size() << endl;
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:47:08
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
#include <cctype>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 multiset에 읽어 왔다.
	
	multiset<String> s;

		
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	String str;
	while (in >> str)
		s.insert(str);

	
	for (const String& str : s)
		cout << str<< endl;
	
	cout << endl << "읽은 multiset의 단어 - " << s.size() << endl;
	save("STL.cpp");
}




================================================
STL.cpp, 저장시간: 2024-05-20 월요일 오후 6:47:33
================================================
//---------------------------------------------------------
// 2024 1학기 STL 5월 20일 월요일
//
// Associative Container - Set
// 
// set은 어떻게 절렬하는가
// 디폴트 less<Key> -> operator< 를 이용한다.
//---------------------------------------------------------
#include <iostream>
#include "save.h"
#include "string.h"
#include <set>
#include <fstream>
#include <cctype>
using namespace std;
extern bool 관찰;


int main()
{
	//[문제] "이상한 나라의 앨리스.txt" 파일에 있는 단어를 multiset에 읽어 왔다.
	
	multiset<String> s;

		
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return 0;
	
	String str;
	while (in >> str)
		s.insert(str);
	
	cout << endl << "읽은 multiset의 단어 - " << s.size() << endl;
	save("STL.cpp");
}

