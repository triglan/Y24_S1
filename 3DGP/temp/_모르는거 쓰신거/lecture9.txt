리소스 - VRAM에, 그림을 그리기 위한 데이터들 (후면 버퍼, 깊이/스텐실 버퍼, 기하 데이터, 텍스쳐, 버퍼, ...)
D3D의 리소스 대분류 - 텍스처, 버퍼

리소스는 파이프라인에 직접 연결되지 않고 서술자(뷰)를 통해 연결됨

리소스
- 커밋 리소스(Committed Resource)
	가상 메모리 공간과 물리적 메모리 공간을 모두 생성
	D3D12에서 힙을 할당할 때 커밋 리소스의 물리적 메모리를 생성함
- 위치 리소스(Placed Resource)
	힙의 어떤 영역에 대한 포인터
- 예약 리소스(Reserved Resource)
	자체적인 GPU 가상 주소
	나중에 가상 페이지를 힙의 어떤 영역으로 매핑할 수 있음
	힙의 영역을 참조할 수 있음 (현재 제공되지 않음?)

리소스 힙과 디스크립터 힙은 분리되어있다.

디스크립터 힙은 CreateDescriptorHeap으로,
DescriptorHeapDesc: 어떤 종류의 DescriptorHeap을 만드는지, 몇 개를 만드는지, 플래그(쉐이더에서 뷰의 가시성 설정), 어댑터 노드 마스크(몇 번 gpu)
- CBV/UAV/SRV (Descriptor Heap에서 차지하는 메모리 크기가 똑같음 -> 같은 Increment Size)
- Sampler
- RTV
- DSV

Vertex Buffer View와 Index Buffer View, Stream Output Buffer View는? -> Descriptor Heap이 없어도 뷰를 만들 수 있다.
그래서 D3D12_DESCRIPTOR_HEAP_TYPE enum에 포함되지 않음

* 어떤 때는 Render Target, 어떤 때는 텍스처인 리소스를 만들고 싶다.: SRV Descriptor Heap, RTV Descriptor Heap 두 개가 필요

CPU 사이드와 GPU 사이드에서 DescriptorHeap의 주소가 다르다.
D3D12_CPU_DESCRIPTOR_HANDLE / D3D12_GPU_DESCRIPTOR_HANDLE

* CPU 사이드 핸들을 쓰는 함수들 vs GPU 사이드 핸들을 쓰는 함수들

Create xx View - 어떤 리소스에 대한 뷰냐, 어떤 형태의 뷰를 만들 거냐(nullptr? 리소스와 똑같은 걸 만들어주세요.), 어디에 저장할 거냐

DSV View의 플래그: None - depth, stencil 둘 다 읽기 가능, READ_ONLY_DEPTH - depth만 읽기 가능, READ_ONLY_STENCIL - stencil만 읽기 가능

D3D12_HEAP_TYPE (리소스 힙 타입): CPU와 GPU의 R/W 권한 분배
	- DEFAULT: GPU는 R/W 가능, CPU는 접근 불가
	- UPLOAD: CPU는 W 가능, GPU는 R 가능, 업로드를 위한 CPU 접근에 최적화
	- READBACK: CPU는 R 가능, GPU는 W 가능, 읽기 위한 CPU 접근에 최적화 (스크린샷 - 렌더타겟을 읽어 CPU로)
