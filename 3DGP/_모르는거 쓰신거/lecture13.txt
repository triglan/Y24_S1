InputLayout은 어디에 들어있나 -> D3D12_GRAPHICS_PIPELINE_STATE(_DESC)

ID3D12Resource::Map pReadRange를 nullptr로 주면 전체 서브리소스의 범위가 됨
Map: COM 객체의 GPU 가상 메모리 주소를 CPU 포인터인 것처럼 얻어옴
Unmap: GPU가 해당 리소스에 대해 더 이상 VRAM 관리를 할 필요가 없다.

Default Heap: GPU 입장에선 빠르고 접근하기 좋음, CPU한테 리소스를 돌려줄 필요가 없음
Upload Heap: CPU가 쓰라고 추가적인 관리를 하는 힙, GPU 입장에선 해야 할 일이 많음

* 임시 메모리 주소가 넘어올 수도 있으므로 필요할 때마다 Map, Unmap하는 게 좋다?

정점 버퍼를 만들때 Default Heap으로 만들면
Map으로 주소를 가져올 수가 없음 -> Upload Heap에 정점 버퍼를 만들고(CPU -> GPU, GPU->GPU보다 100배 정도 오래 걸림)
Upload Heap의 내용을 Default Heap에 복사(GPU -> GPU)

* Upload Heap의 내용을 Copy하는 것을 CommandList에 넣었다고 해서 바로 실행되는 것이 아니므로,
  Upload Heap을 그 명령이 Execute될 때까지 유지해야 한다.

Upload Heap의 영구적 매핑: GPU는 가상 메모리를 쓰니까 실시간으로 물리적 주소가 바뀔 수 있잖아?
	-> 논리적 주소와 물리적 주소의 매핑 테이블을 갖춤,
		-> CPU가 unmap 호출할 일 없이 한 번 map해놓고 계속 쓸 수 있음

Readback Heap: 잘 안 씀, 역시 GPU에 있는 걸 CPU로 읽어들이기 때문에 100배 느림.
* 렌더타겟 읽어들일 때, 이 때도 역시 Default Heap에서 copy하고 그걸 또 CPU로 copy

비동기 copy에 어떻게 대응할 것인가? -> Resource Barrier

CopyBufferRegion, CopyTextureRegion -> CopyResource의 partial copy 버전

입력 조립기에는 16개의 버퍼 연결 가능
*OM은 8개의 렌더 타겟

INPUT_ELEMENT_DESC에 행렬을 담을 때에는 4개의 벡터를 담는 것처럼 한다.
	-> DXGI_FORMAT의 한계 때문에?