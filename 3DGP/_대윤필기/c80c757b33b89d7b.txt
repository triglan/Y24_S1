lib-어디로 이동해야하는지 알려준다, 

프레임버퍼
모니터로 출력되어야 하는 비디오 메모리 
프레임->출력되는 하나의 장면
프레임 레이트-> 1초동안 출력되는 평균프레임수
의미있는 FPS=>60Hz
처리하는 알고리즘 문제, 화면에 그릴게 많거나->프레임레이트 낮아짐

색상 표현
rgb로 표현  

<d3d 디바이스>
더블버퍼링
후면버퍼에서 전면버퍼로 빠르게 옮긴다->프리젠테이션
스왑체인:순차적으로 연결되 ㄴ프레임 버퍼들의 집합
플리핑:하드웨어적인 방법으로 전면버퍼와 후면버퍼를 바꾸는 방법 ex)붕어빵 생각
프리젠테이션하려면 플리핑해야함
후면버퍼 여러개 만들면서 멀티스레드를 이용하면 효율적으로 작업 처리
즉, 목표는 스왑체인을 만들자!

COM(component(부분장비들?) object model)
com오브젝트는 딜리트를 하면 안됌 
생성할땐 크리에이트함수 +1 
addref로 복사,사용함을 알려줘야함 +1해줌
지울땐 releas를 호출하면 -1하여 0이 되는데 0이 된 것들을 os가 지워줌(delete쓰지X)
이 객체가 어떤 인터페이스를 제공하는가를 알려줌->quweyinerface
void**ppDevice
create함수들은 마지막 파라미터가 **임

DXGI
:모니터 몇개 연결되었는지 프리젠트 화면모드 등을 관리한다
팩토리 생성하기-홈객체를 생성create로 생성 release로 삭제

create함수은com객체를 생성한다
ckeckfeaturesupport-디바이스의 세부적인 정보를 확인 할 수 있음
createrendertagetview 
view=리소스와 관련(readonly 비디오메모리(프레임버퍼))
, 객체의 어떠한 정보(버퍼에 어떻게 쓸거야 라고 알려줌)
후면버퍼가 rendertarget이 됌
3d3는 그리는 용도
 
dxi_swap_chain_flag-비트자리를 정해서 여러개를 썪어서 넣어도됌
allow_mode_switch(전체화면)를 resizebuffers resizetarget을 사용해야함
옛날-상위 하위필드 번갈아 가면서 보여줌
현재-모든 라인 보여줌

view에 depth표현
다중샘플링-ckeckfeaturesupport에서 count quality알 수 있음
1. 슈퍼샘플링-픽셀많은 곳(큰 화면)에 그리고 축소해서 화면에 출력
2. MSAA-

//4/12
DXGIswapchain 으로 버퍼 제공받고
이에 대한 함수들이 있음
백버퍼에 d3d를 이용하여 그림을 그릴거임
뷰를 넘겨주기위해 백버퍼를 가져옴(GetBuffer로 백버퍼 가져옴)
present함수: 후면버퍼를 전면버퍼에다 옮긴다
1(1번만수직회귀후 프리젠트)~4를사용 0사용하면 후면버퍼에서 옮겨진 그림이 썩겨서 나올 수 있다

creatSwapChainForHwnd 그냥 앞의 create스왑체인과 기능과 비슷
Stereo입체영상 출력(우리는 사용X)
윈도우 모드vs전체 화면 모드
dxgifectory에서 전체화면과 윈도우모드 전환 안되게 막을 수 있음
모드변환일어나면 저면버퍼의 크기를 DXGI가 자동으로 변경함
resizeBuffers
후면버퍼의 개수,크기를 바꾸기 위해 사용할 수 있음
resizebuffer함수 호춯해야함-크기에 맞는 버퍼를 하나더 만든다
GPU-쉐이더?
d3d에서 조작
서로 동기화하여 동작이루어 져야함
계산하기 우한 명령들-컴퓨터큐
그림을 그릴때 (device)상태변화를 얼마나 최소한으로 하느냐
command list가 변활때가 상태변화라고 할 수 있음
d3d에다 command queue를 만들어야함
command Allocator를 만들고 command들을 넣고 그 command들을 모아서 각각의 command list
를 만들어 큐에 집어 넣는다
command list open-command를 집어 넣을 수 있다
close일때는 못집어 넣고 gpu에 넘겨줄 수 있는 상태가 만들어 진다
Reset으로 open상태로 만들어주지
프레임1이 넣은 command list를 다 실행하고 프레임2를 command list들을 넣어준다
아니면 리소스 꼬여서 잘못된 그림을 그림
팬스우리는 기본값으로 할거다
getEvantOnValue 현재팬스의 값을 알려준다
write,read를 하려고 할때는 항상 동기화를 해줘야 한다
다 쓰기 전까지 읽지 않는다(동기화)->CreateEvent호출해주면 os에서 알아서 해준다
팬스는 gpu가 명령리스트들을 다 실행했는가를 cpu에게 알려주기 위해 사용하는데
setEventOnCompletion이벤트를 발생시킴->cpu에게 알려준다
signal호출->cpu가 팬스관련 함수 큐에 집어넣고 그것이 실행되면 setEventOnCompletion발생 

//4/16
리소스
1.버퍼,2.텍스쳐 로 나누어짐
파이프라인에 사용이 될때 뷰형태로 바꾸어서 이용해야함

커밋리소스(우리가 사용할것)
가상,물리메모리 동시에 할당해줌, 
video memory 할당받으면 이것을 리소스라고 함(heap)
디바이스-그래픽스, 컴퓨트
리소스를 디바이스와 연결하는것을 바인드or set이라고 함
뷰(descriptor)를 만들고 이를 디바이스에 넘겨줌/ 디스크립트 힙의 주소(핸들)
디스크립트 힙의 뷰의 타입은 4개로 나누어진다

gpu에서 실해되고 있는 프로그램->shader라고 할거임
리소스하나를 각각 다른 타입으로 만들고 싶으면
각 디스크립터 별로 나누고 각 리소스마다 만들고 싶은 타입의 디스크립터에 집어
넣으면 됌

gpu memory에 리소스들이 있고 qpu memory가 디스크립터 힙에 찾아가기 위해서의 따로 함수
있음
cpu로 디스크립터에 접근할때 따로 함수 있음 즉, 서로 접근할때 가상주소을 받기 때문에 받는 주소가
다르다(함수 쓰면 디스크립터 배열의 첫 주소 받음 여기엔 타입이 몇개씩 있는지 알음)
각 타입의 크기를 알아야 하고 그 크기를 통해 각 타입의 원하는 뷰를 얻을 수 있음
핸들을 파라미터로 사용하는 함수들->93p
 
백버퍼를 랜터타겟으로 만들고 싶다
rtv ,디스크립트를 만들고, rtv를 만들고 이를 넣는다 
뷰란 무엇인가-리소스의 정보를 담고있음

댑스버퍼 필요 함
DSV의 힙이 하나만 있으면 됌
stencil-접근할거냐 안할거냐 알려줌
리소스를 만들어야함 (비디오메모리)
힙타입-디폴트로 주면 gpu만 읽쓰가능,업로드 cpu업로드(쓰기),gpu읽기,readback cpu읽기gpu쓰기
gpu가 만들고 데이터를 cpu로 보여줄때-readback
unknown- 알아서 해줘

힙플레그-
clear value- 어떤 값을 어떻게 지울건지 알려주기
리소스들 다양한 상태를 가질 수 있음-상태 관리
버퍼는 그냥 배열 텍스쳐는 구조화 되어있는 구조체 형태
dimension은 

스왑체인 인덱스는 디스크립터의 어느뷰를 접근할것인가
clearRTV-
clearDSV
따라하기 34분
virtual memory

omssetrendertargets()-백버퍼에 렌터타겟 디스크립터를 set해줌(넘겨준다) 
한번에 여러개 set할 수 있음(8개)
handle의 시작주소를 넘겨준다?디스크립터 배열 첫번째주소
즉넘겨줄때 연속된 서술자이여야함(연속아니면False)
Rasterizer stage
뷰포트:투영변환 끝나고 스크린에 어느 사각형으로 옮길것인가
RSSetViewports-뷰포를 set할 수 있음
커멘드 리스트 리셋되면 이 함수 호출해서 set해줘야 함
시저렉트-제거하지 않을 사각형을 표현(RSSetscissorRect())

리소스장벽
리소스에 대한 상태 관리를 위해 만들어짐
리소는 상태를 가지고 있음
dxgi가 read(프리젠트) 하면 안됨 om(output model)이 리소스에 쓰고 있을때
생각:리소스가 rtv에 정보넘겨주고 om이 그에  따라 리소스에 그림을 그린다
전이 장벽:리소스 상태전이를 하기위해
recourceBarrier-리소스에 대한 상태를 알아야해 라고 알려주는 함수(만드는 것아님)
이전 상태와 이후의 상태 를 넣어주고 디바이스 내부에서 상태 알아서 바꿔줌 

//-------------------------------------------------------------------------------------------
//파이프라인
쉐이더는 비어있기 때문에 우리가 채워줘야함
고정프로그램단계-이미 정해져있음
프로그램 가능 단계-프로그램 쉐이더 프로그램제공
파이프라인-10개의 함수들-Draw함수를 통해 10개의 함수들이 단계적으로 실행됌
앞에서 배운 RSset같은 함수들을 사용하여 설정해주면 그에 마춰 실행된다
즉 draw()하기 전에 열가지 set을 해야함
ia-보통 모델정보가 들어가있음,데이터를 넘겨주는방법-파라미터o or 글로벌x

입력-조립단계
입력 리소스-모델데이터-정점들의 배열->set()
프리미티브
3각형인지 선인지 구성을 알려주고 해석방법 알려주어야함->조립해준다
시멘틱을 만들어준다-번호?                   //어떤 랜터타겟에 그려줄 것인가?
3각형 그려줄때 1번정점 2번정점인지 알려주기(시멘틱붙여줘서)

vs-u*w*v*p

래스터라이저단계
프리미티브를 픽셀로(래스터)이미지로 변환
원근투영 나누기->클리핑수행->2d뷰포트 매핑->픽셀쉐이더 호출
정점들 모델좌표계에 있다->표현하는 사람 마음(좌표계에 모델이 어디에 표현?)
인터폴레이션과정을 거친다

//4/35
출력병합 단계
뎁스스텐실버퍼+픽셀색상들
뎁스스텐실검사(세부적2학기)
-정렬을 하지 않기 위해 뎁스버퍼가 있다, 뎁스값을 비교하여 픽셀색상을 결정하게 된다-
-뎁스스텐실에 안그리는 부분은 0 그리는 부분은 1로 둔다
-뎁스스텐실 버퍼가 파이프라인에 연결되지 않으면 스텐실 검사는 항상 성공함
블렌딩
렌더타겟에서는 이미 픽셀색을 가지고 있음 그 픽셀과 다른픽셀을 섞어서 최종 색상생성
불투명그려놓고 투명한것 그리면서 블렌딩한다(순서외우기)
불투명리스트와 투명리스트만들어서 불투명먼저! 아니면 블렌딩 방법없음
ex)땅에 물이 고여있는것을 볼때 물색상만 보이는 것이 아닌 땅색이 썪여서 보임
//파이프라인(블렌,뎁스스텐실)(2학기때 넘어가자)
쉐이더 단계(버텍스,픽셀만 다룰거임)
입력데이터-> 쉐이더코드   -> 출력데이터
메모리 리소스-버퍼(배열이라 생각)
,텍스쳐(2d이미지들)->샘플러라고 하는 오프젝트를 통해 쉐이더코드에 접근 가능
,상수 버퍼(바뀔수 있는데 자주 바뀌지 않는다는 뜻)->파이프라인이 시작하고 끝날때 까지는 
상수의 의미를 가진다(변환행렬)
입력데이터는 쉐이더코드에 파라메타로 넘겨주고 
메모리 리소스들은 전역으로 넘겨준다

정점쉐이더 단계
입력조립기가 넘겨주는 모델정점들에 대해 
변환(or스키닝(관절을 통해 정점들 바뀜)or조명or morphing(다른 물체들로 바꿔주는))을 하는 단계
정점더 생기거나 위치가 바뀔 수 있음
정점쉐이더를 통해 무조건 넘겨줘야함
하나의 정점에 대해 한번 호출

픽셀쉐이더 단계
4x면 4개의 서브 픽셀들이 생김(위아래 옆늘리니까)
최대 칼라벡터 8개의 색상으로 출력가능
픽셀의 색을 결정하기 위해 각 픽셍에 대해 픽셀쉐이더 한번씩 호출
lihgting을 통해 텍스처,light 계산을 하게 됌->조명계산을 할 수 있음
픽셀의 개수만큼 라이팅함
프레임메이트가 왔다갔다 하는것이 조금하는 것이 좋은 프로그래밍

필요에따라 조명계산을 정점이나 픽셀 쉐이더에서 할 수 있다

파이프라인상태의 생성
createGraphicsPipelineState로 생성
set할 수 잇는 함수들-각 파이프라인에 있는 것들의 상태을 set

정점쉐이더단계준비
HLSL
Blob에 연결 바이트코드를
D3D_file_include-쉐이더를 컴파일


래스터라이저 단계
폴리곤을 칠한다 fill_mode(면solid/선wireframe)
그리지 않을 면 방향cull_mode(전면,후면(디폴트임) 그리지마)
시계방향이 전면임(디폴트)
counterclock-반시계 즉,false로 설정
뎁스클리핑-true 

래스터라이저 단계 준비
프리미티브에 조금이라도 걸치면 색칠함
뷰포트 시저랙트- 어느부분을 그릴거냐를 표현
뷰포트 설정-topleft(x,y),width, height
-> 뷰포트셋을 하여 윈도우안에서 2명의 플레이어로 게임을 한다고하면
각 객체에는 카메라가있고 뷰포트로 설정르로 화면 나누어서 게임 할 수 있음
즉, 카메라1 변환 행렬를 활용하여 왼쪽에 그리고 케메라2는 오른쪽에 그린다

정점버퍼 사용하지 않고 렌더링하기
디바이스 적당하게 set해주고 draw해주면 됌->3각형 출력
시맨틱 이라슨 것이 중요 입력조립기에 있는 것들을 넘겨준다

프레임워크 구조 좋은 구조 그때그때 다르다
//----
<<파이프라인2>>
리소스-정적데이터-미리 넣어줄 수 있다(load),create함수를 만들어 리소스를 만든다
device에서 실행-정점버퍼 인덱스 버퍼는 입력 리소스
,동적데이터-set and draw

입력조립단계 준비
입력리소스를 넘겨준다
입력버퍼객체를 생성
입력 버퍼에 대한 뷰를 생성-즉, 뷰를 입력조립단계에 연결한다
입력 레이아웃생성-한원소의 크기,각각의 색 등을 알려준다
레이아웃 파이프라인 상태에 연결
프리미티브 지정-조립한다
입력버퍼를 입력조립단계에 연결
호출

map-실제메모리주소가져옴
비디오메모리 주소가져와서 리소스를 채워넣을 수 있음,gpu가 관리?
unmap으로 gpu가 더이상 관리하지 않는다고 알려줌
3개의 힙
디폴트힙-gpu는 리소스를 넣다 뺄수 있는데 cpu는 접근조차 못함-안바뀔거야
업로드힙-비디오메모리에 cpu에 있는리소스를 쓸 수 있다
gpu는 둘다 접근가능하기 때문에 복사를 통해 필요한 정보 얻을 수 있음-copyresource()
커멘트리스트는 큐에 들어있다가 쌓였다가 때가 되면 명령들이 실행(copyresource()도 )
즉, 리소스를 업로드힙을 카피가 될때 까지 기다렸다 없애줘야 함
업로드힙의 비디오메모리는 자주바뀔꺼야기 때문에 사용하는것임
실제 cpu가 접근하려는 주소는 바뀌지않는다-**ppData 
cpu가 비디오메모리에 접근하는 것은 되도록 줄여야하함-매우 느리다
read는 거기서 더더 느리다-쓰면 거의 안됌 write보다 100배 느림
랜더타켓에 있는 내용을 복사하여 파일로 저장할때만 거의 사용-readback
cpu엔 이미 없고 
gpu에 리소스의 일부 영역을 복사할 수 있음(업로드힙 할때)

레이아웃-입력버퍼의 구조를 표현

정점조립
메쉬는 정점데이터-pos,노말,색,텍쳐 코디네이트
인스턴스는 객체의 월드변환행렬, 위치 데이터
정렬오프셋자리에 어펜드엘리전트엘리멘트 함수 쓰면 알아서 다음 정점으로 가는 바이트 셋해줌

시멘틱-어디위치부터는 정점으로사용4*3(position 시멘틱),
 어느위치부터는 색으로 사용4*3(color시멘틱)
24바이트씩 
 inputelement 슬롯번호에 연결된 번호 적고 몇번째 인덱스 부터가 그에 대한 정보인지 알
려주면 된다// 슬롯0-정점데이터, 컬러데이터 연결 슬롯1- 인스턴스데이터 연결
인스턴스4x4 행렬로 만들어줄때 슬롯1에 4개의 행들을 나타내주고 각 시작위치알려줘야함
또한 인스턴스 이름이 똑같기 때문에 인덱스값 다르게 입력(구분이 됌)

정보들 많아지면 그 정보의 구조체를 하나로 만들어주는 것이아니라 각각의 슬롯으로 만들어서
세로로 입력조립기가 읽는다. 각각의 여러오브젝트들이 가지고 있는 정보들이 다를때 
어느 오브젝트들이라도 어떤것은 어떤슬롯을 연결하지 않으면 된다.

 

















































